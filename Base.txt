using System;
using System.IO;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using Microsoft.Win32;

namespace BedrockAntiCheatScanner
{
    public partial class Main : Form
    {
        private Color backgroundColor = Color.FromArgb(245, 245, 245);
        private Color primaryColor = Color.FromArgb(75, 110, 175);
        private Color textColor = Color.FromArgb(50, 50, 50);
        private Color successColor = Color.Green;
        private Color warningColor = Color.OrangeRed;
        private Color alertColor = Color.DarkOrange;
        private HashSet<string> knownGameDlls = new HashSet<string>();
        private HashSet<string> baselineModules = new HashSet<string>();
        private HashSet<string> initialMinecraftFiles = new HashSet<string>();
        private string serverBaseUrl = "http://extreme4m5n.creepercloud.io:26414";
        private static readonly HttpClient httpClient = new HttpClient();
        private string registryKeyName = "Software\\Cryon\\Mist";
        private string deviceIdValueName = "DeviceId";
        private string linkedGamertagValueName = "LinkedGamertag";
        private string uuidValueName = "uuid";
        private ComboBox processDropdown;
        private Button compareButton;
        private System.Windows.Forms.Timer processUpdateTimer;
        private HashSet<string> windowsProcesses;
        private Dictionary<string, byte[]> knownHackClients = new Dictionary<string, byte[]>(); // To store hack client DLLs from resources

        public Main()
        {
            InitializeComponent();
            LoadWindowsProcessList();
            LoadHackClientDlls(); // Load hack client DLLs from resources
            ApplyCustomStyle();
            InitializeLinkAccountControls();
            InitializeProcessListUpdates();
            statusLabel.Text = "Ready to Scan";
            LoadStaticBaselines();
            StartPeriodicMinecraftCheck();
            CheckLinkedAccountOnStartup();
            this.DoubleBuffered = true;
        }

        private void LoadHackClientDlls()
        {
            // Example of loading horion.dll - add more as needed
            try
            {
                byte[] horionBytes = Properties.Resources.horion; // Assuming you have horion.dll in your resources
                if (horionBytes != null && horionBytes.Length > 0)
                {
                    knownHackClients.Add("Horion", horionBytes);
                }
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error loading Horion DLL from resources: {ex.Message}", Color.DarkRed);
            }

            try
            {
                byte[] borianBytes = Properties.Resources.borian; 
                if (borianBytes != null && borianBytes.Length > 0)
                {
                    knownHackClients.Add("Borion", borianBytes);
                }
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error loading Borian/Bobion DLL from resources: {ex.Message}", Color.DarkRed);
            }

            try
            {
                byte[] borianBytes = Properties.Resources.WINMM; 
                if (borianBytes != null && borianBytes.Length > 0)
                {
                    knownHackClients.Add("Borion", borianBytes);
                }
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error loading Borian/Bobion DLL from resources: {ex.Message}", Color.DarkRed);
            }

            // Add more hack client DLL loading here if you have them in resources
            // Example for another client named 'Nuvola':
            // try
            // {
            //     byte[] nuvolaBytes = Properties.Resources.nuvola;
            //     if (nuvolaBytes != null && nuvolaBytes.Length > 0)
            //     {
            //         knownHackClients.Add("Nuvola", nuvolaBytes);
            //     }
            // }
            // catch (Exception ex)
            // {
            //     UpdateStatusLabel($"Error loading Nuvola DLL from resources: {ex.Message}", Color.DarkRed);
            // }
        }

        private void LoadWindowsProcessList()
        {
            try
            {
                string windowsProcessText = Properties.Resources.winp;
                windowsProcesses = new HashSet<string>(
                    windowsProcessText.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
                    .Select(process => process.Trim().ToLower())
                );
                Console.WriteLine($"Loaded {windowsProcesses.Count} Windows processes");
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error loading Windows process list: {ex.Message}", Color.DarkRed);
                windowsProcesses = new HashSet<string>(); // Initialize empty set if loading fails
            }
        }

        private void InitializeProcessListUpdates()
        {
            // Initialize the timer for process list updates
            processUpdateTimer = new System.Windows.Forms.Timer();
            processUpdateTimer.Interval = 5000; // Update every 5 seconds
            processUpdateTimer.Tick += ProcessUpdateTimer_Tick;
            processUpdateTimer.Start();

            // Set up the compare button click event
            compareButton.Click += CompareButton_Click;

            // Initial population of the process list
            UpdateProcessList();
        }
        private void ProcessUpdateTimer_Tick(object sender, EventArgs e)
        {
            UpdateProcessList();
        }
        private void InitializeProcessControls()
        {
            // Create process dropdown
            processDropdown = new ComboBox();
            processDropdown.Location = new Point(12, 250);
            processDropdown.Size = new Size(200, 23);
            processDropdown.DropDownStyle = ComboBoxStyle.DropDownList;
            this.Controls.Add(processDropdown);

            // Create compare button
            compareButton = new Button();
            compareButton.Location = new Point(220, 250);
            compareButton.Size = new Size(100, 23);
            compareButton.Text = "Compare DLLs";
            compareButton.BackColor = primaryColor;
            compareButton.ForeColor = Color.White;
            compareButton.FlatStyle = FlatStyle.Flat;
            compareButton.FlatAppearance.BorderSize = 0;
            compareButton.Click += CompareButton_Click;
            this.Controls.Add(compareButton);

            // Start periodic process list update
            StartProcessListUpdate();
        }

        private async void StartProcessListUpdate()
        {
            while (true)
            {
                UpdateProcessList();
                await Task.Delay(5000); // Update every 5 seconds
            }
        }

        private void CompareButton_Click(object sender, EventArgs e)
        {
            if (processDropdown.SelectedItem == null)
            {
                MessageBox.Show("Please select a process to compare.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            try
            {
                string selectedProcess = processDropdown.SelectedItem.ToString();
                int processId = int.Parse(selectedProcess.Split('(', ')')[1]);

                using (Process process = Process.GetProcessById(processId))
                {
                    HashSet<string> processDlls = new HashSet<string>();

                    foreach (ProcessModule module in process.Modules)
                    {
                        processDlls.Add(module.ModuleName.ToLower());
                    }

                    // No Nitro check here anymore

                    UpdateStatusLabel($"Compared DLLs for process: {process.ProcessName}", successColor);

                    // Optionally show the DLLs
                    fileList.Items.Clear();
                    fileList.Items.Add($"DLLs for {process.ProcessName}:");
                    foreach (string dll in processDlls)
                    {
                        fileList.Items.Add($"  â€¢ {dll}");
                    }
                }
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error comparing process DLLs: {ex.Message}", Color.DarkRed);
                MessageBox.Show($"Error accessing process: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void UpdateProcessList()
        {
            try
            {
                if (InvokeRequired)
                {
                    Invoke(new Action(UpdateProcessList));
                    return;
                }

                string selectedProcess = processDropdown.SelectedItem?.ToString();
                processDropdown.Items.Clear();

                var processes = Process.GetProcesses()
                    .Where(p => !IsWindowsProcess(p)) // Filter out Windows processes
                    .OrderBy(p => p.ProcessName)
                    .Select(p => {
                        try
                        {
                            return $"{p.ProcessName} ({p.Id})";
                        }
                        catch
                        {
                            return null;
                        }
                    })
                    .Where(p => p != null);

                foreach (string processDisplay in processes)
                {
                    processDropdown.Items.Add(processDisplay);
                }

                if (selectedProcess != null && processDropdown.Items.Contains(selectedProcess))
                {
                    processDropdown.SelectedItem = selectedProcess;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error updating process list: {ex.Message}");
            }
        }

        private bool IsWindowsProcess(Process process)
        {
            try
            {
                // Check if the process name (without .exe) is in our Windows process list
                string processName = process.ProcessName.ToLower();
                return windowsProcesses.Contains(processName) ||
                       windowsProcesses.Contains(processName + ".exe");
            }
            catch
            {
                return false; // If we can't access the process, don't filter it out
            }
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);
            if (processUpdateTimer != null)
            {
                processUpdateTimer.Stop();
                processUpdateTimer.Dispose();
            }
        }

        private void ApplyCustomStyle()
        {
            this.BackColor = backgroundColor;
            this.ForeColor = textColor;
            fileScanButton.BackColor = primaryColor;
            fileScanButton.ForeColor = Color.White;
            fileScanButton.FlatStyle = FlatStyle.Flat;
            fileScanButton.FlatAppearance.BorderSize = 0;

            statusLabel.ForeColor = textColor;
            statusLabel.TextAlign = ContentAlignment.MiddleCenter;
            minecraftStatusLabel.ForeColor = textColor;
            minecraftStatusLabel.TextAlign = ContentAlignment.MiddleLeft;

        }
        private void InitializeLinkAccountControls()
        {
            linkAccountButton.Click += LinkAccountButton_Click;
            unlinkAccountButton.Click += UnlinkAccountButton_Click;
            flushButton.Click += FlushButton_Click;

        }

        private void FlushButton_Click(object sender, EventArgs e)
        {
            ClearLinkingInformation();
            linkedAccountLabel.Text = "Not Linked";
            linkAccountButton.Enabled = true;
            unlinkAccountButton.Enabled = false;
            MessageBox.Show("Client linking data flushed.", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
        private async void StartPeriodicMinecraftCheck()
        {
            while (true)
            {
                CheckMinecraftRunning();
                await Task.Delay(1000);
            }
        }

        private void CheckMinecraftRunning()
        {
            Process[] minecraftProcesses = Process.GetProcessesByName("Minecraft.Windows");
            if (InvokeRequired)
            {
                Invoke(new Action(() =>
                {
                    UpdateMinecraftStatus(minecraftProcesses);
                    PerformBaselineCheck(minecraftProcesses);
                }));
            }
            else
            {
                UpdateMinecraftStatus(minecraftProcesses);
                PerformBaselineCheck(minecraftProcesses);
            }
        }

        private void UpdateMinecraftStatus(Process[] minecraftProcesses)
        {
            if (minecraftProcesses.Length > 0)
            {
                minecraftStatusCircle.BackColor = Color.ForestGreen;
            }
            else
            {
                minecraftStatusCircle.BackColor = Color.Red;
            }
        }

        private void PerformBaselineCheck(Process[] minecraftProcesses)
        {
            if (minecraftProcesses.Length > 0)
            {
                Process minecraftProcess = minecraftProcesses[0];
                try
                {
                    HashSet<string> currentModules = new HashSet<string>();
                    foreach (ProcessModule module in minecraftProcess.Modules)
                    {
                        currentModules.Add(module.ModuleName.ToLower());
                    }

                    var newModules = currentModules.Except(baselineModules).ToList();
                    if (newModules.Any())
                    {
                        foreach (string newModule in newModules)
                        {
                            UpdateStatusLabel($"WARNING: New DLL detected since baseline: {newModule}", warningColor);
                            fileList.Items.Add($"[Injected] {newModule}");

                            try
                            {
                                string moduleFilePath = minecraftProcess.Modules.Cast<ProcessModule>()
                                    .FirstOrDefault(m => m.ModuleName.ToLower() == newModule)?.FileName;

                                if (!string.IsNullOrEmpty(moduleFilePath) && File.Exists(moduleFilePath))
                                {
                                    byte[] injectedDllBytes = File.ReadAllBytes(moduleFilePath);

                                    foreach (var kvp in knownHackClients)
                                    {
                                        string hackClientName = kvp.Key;
                                        byte[] knownClientBytes = kvp.Value;

                                        double similarity = CalculateSimilarity(injectedDllBytes, knownClientBytes);

                                        // **New: Hashing Check**
                                        string injectedDllHash = CalculateFileHash(moduleFilePath);
                                        string knownClientHash = CalculateFileHash(kvp.Value); // Assuming you can calculate hash from byte array or have pre-calculated hashes

                                        bool hashMatch = injectedDllHash == knownClientHash;

                                        if (similarity >= 0.95 || hashMatch) // Combine checks
                                        {
                                            string message = $"ALERT: Potential {hackClientName} hack client detected: {newModule}";
                                            if (similarity >= 0.95) message += $" ({similarity:P2} similarity)";
                                            if (hashMatch) message += (similarity >= 0.95 ? " and" : "") + " (Hash match)";
                                            UpdateStatusLabel(message, alertColor);
                                            fileList.Items.Add($"[ALERT - {hackClientName}] {newModule}");
                                            break; // Break if a match is found
                                        }
                                    }
                                }
                                else
                                {
                                    UpdateStatusLabel($"Could not access or find file for injected DLL: {newModule}", warningColor);
                                }
                            }
                            catch (Exception ex)
                            {
                                UpdateStatusLabel($"Error comparing injected DLL {newModule}: {ex.Message}", warningColor);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    UpdateStatusLabel($"Error checking for injections: {ex.Message}", Color.DarkRed);
                }
            }
        }

        private string CalculateFileHash(byte[] byteArray)
        {
            using (var sha256 = SHA256.Create())
            {
                byte[] hashBytes = sha256.ComputeHash(byteArray);
                return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
            }
        }
        private double CalculateSimilarity(byte[] array1, byte[] array2)
        {
            if (array1 == null || array2 == null || array1.Length == 0 || array2.Length == 0)
            {
                return 0;
            }

            int commonBytes = 0;
            int minLength = Math.Min(array1.Length, array2.Length);

            for (int i = 0; i < minLength; i++)
            {
                if (array1[i] == array2[i])
                {
                    commonBytes++;
                }
            }

            return (double)commonBytes / Math.Max(array1.Length, array2.Length);
        }

        // Helper function to calculate byte-by-byte similarity

        private async void fileScanButton_Click(object sender, EventArgs e)
        {
            fileList.Items.Clear();
            UpdateStatusLabel("Scanning Files...", textColor);
            fileScanButton.Enabled = false;
            bool hackClientPreviouslyInjected = await PerformFileScan();
            fileScanButton.Enabled = true;
            if (hackClientPreviouslyInjected)
            {
                UpdateStatusLabel("WARNING: Potential hack client files found!", warningColor);
            }
            else if (statusLabel.ForeColor != Color.DarkRed)
            {
                UpdateStatusLabel("No known hack client files detected.", successColor);
            }
        }

        private async System.Threading.Tasks.Task<bool> PerformFileScan()
        {
            bool hackClientPreviouslyInjected = false;
            string username = Environment.UserName;
            string roamingstatePath = $@"C:\Users\{username}\AppData\Local\Packages\Microsoft.MinecraftUWP_8wekyb3d8bbwe\RoamingState";
            string tempPath = $@"C:\Users\{username}\AppData\Local\Temp";
            string[] knownHackClients = { "Prax", "Horion", "Bobion" ,"Borion" }; // Keep this for file system based scans

            if (Directory.Exists(roamingstatePath))
            {
                try
                {
                    hackClientPreviouslyInjected = await ScanDirectory(roamingstatePath, "[RoamingState]", knownHackClients);
                }
                catch (Exception ex)
                {
                    UpdateStatusLabel($"Error scanning RoamingState: {ex.Message}", Color.DarkRed);
                }
            }
            else
            {
                UpdateStatusLabel($"Error: RoamingState directory not found.", Color.DarkRed);
            }

            if (Directory.Exists(tempPath))
            {
                try
                {
                    if (HasDllFile(tempPath))
                    {
                        UpdateStatusLabel($"WARNING: DLL file found in Temp directory.", warningColor);
                        hackClientPreviouslyInjected = true;
                        // You might want to list the specific DLL files found for more detail
                        foreach (string dllFile in Directory.GetFiles(tempPath, "*.dll"))
                        {
                            fileList.Items.Add($"[Temp] {Path.GetFileName(dllFile)}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    UpdateStatusLabel($"Error scanning Temp: {ex.Message}", Color.DarkRed);
                }
            }
            else
            {
                UpdateStatusLabel($"Error: Temp directory not found.", Color.DarkRed);
            }

            return hackClientPreviouslyInjected;
        }

        private bool HasDllFile(string path)
        {
            return Directory.GetFiles(path, "*.dll").Length > 0;
        }

        private async System.Threading.Tasks.Task<bool> ScanDirectory(string path, string prefix, string[] knownHackClients)
        {
            bool hackClientPreviouslyInjected = false;
            string[] fileSystemEntries = Directory.GetFileSystemEntries(path);
            foreach (string entry in fileSystemEntries)
            {
                string itemName = Path.GetFileName(entry);
                fileList.Items.Add($"{prefix} {itemName}");
                string itemNameWithoutExtension = Path.GetFileNameWithoutExtension(itemName).ToLower();
                if (knownHackClients.Any(hackClient => itemNameWithoutExtension.Contains(hackClient.ToLower())))
                {
                    hackClientPreviouslyInjected = true;
                }
            }
            return hackClientPreviouslyInjected;
        }

        private void Main_Load(object sender, EventArgs e)
        {
            CheckMinecraftRunning();
            Task.Run(CheckForUpdates); // Check for updates when the form loads
        }

        private async Task CheckForUpdates()
        {
            string clientExecutablePath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            string clientHash = CalculateFileHash(clientExecutablePath);

            try
            {
                var requestData = new { clientHash = clientHash };
                string jsonData = JsonSerializer.Serialize(requestData);
                var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await httpClient.PostAsync($"{serverBaseUrl}/api/checkupdate", content);

                if (response.IsSuccessStatusCode)
                {
                    string responseContent = await response.Content.ReadAsStringAsync();
                    var updateResponse = JsonSerializer.Deserialize<UpdateResponse>(responseContent);

                    if (updateResponse != null && !updateResponse.isUpToDate)
                    {
                        DialogResult result = MessageBox.Show("A new version of the anti-hack client is available. Download now?", "Update Available", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
                        if (result == DialogResult.Yes)
                        {
                            if (!string.IsNullOrEmpty(updateResponse.downloadUrl))
                            {
                                try
                                {
                                    System.Diagnostics.Process.Start(serverBaseUrl + updateResponse.downloadUrl);
                                }
                                catch (Exception ex)
                                {
                                    MessageBox.Show($"Error opening download link: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                }
                            }
                            else
                            {
                                MessageBox.Show("Download URL not provided by the server.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            }
                        }
                    }
                    else if (updateResponse != null && updateResponse.isUpToDate)
                    {
                        UpdateStatusLabel("Client is up to date.", successColor);
                    }
                }
                else
                {
                    UpdateStatusLabel($"Error checking for updates: {response.StatusCode} - {response.ReasonPhrase}", warningColor);
                }
            }
            catch (HttpRequestException ex)
            {
                UpdateStatusLabel($"Error communicating with update server: {ex.Message}", alertColor);
            }
            catch (JsonException ex)
            {
                UpdateStatusLabel($"Error parsing update response: {ex.Message}", alertColor);
            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"An unexpected error occurred during update check: {ex.Message}", alertColor);
            }
        }

        private string CalculateFileHash(string filePath)
        {
            using (var sha256 = SHA256.Create())
            {
                using (var stream = File.OpenRead(filePath))
                {
                    byte[] hashBytes = sha256.ComputeHash(stream);
                    return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
                }
            }
        }

        private void minecraftStatusLabel_Click(object sender, EventArgs e)
        {

        }

        private void statusLabel_Click(object sender, EventArgs e)
        {

        }

        private void UpdateStatusLabel(string text, Color color)
        {
            if (InvokeRequired)
            {
                Invoke(new Action(() => {
                    statusLabel.Text = text;
                    statusLabel.ForeColor = color;
                }));
            }
            else
            {
                statusLabel.Text = text;
                statusLabel.ForeColor = color;
            }
        }
        private async void LinkAccountButton_Click(object sender, EventArgs e)
        {
            linkCodeTextBox.Visible = true;
            linkCodeTextBox.Focus();
            linkCodeTextBox.KeyDown += async (s, args) =>
            {
                if (args.KeyCode == Keys.Enter)
                {
                    await LinkClientToServer(linkCodeTextBox.Text);
                    linkCodeTextBox.Visible = false;
                    linkCodeTextBox.Clear();
                }
            };
        }

        private async Task LinkClientToServer(string linkCode)
        {
            if (string.IsNullOrWhiteSpace(linkCode))
            {
                MessageBox.Show("Please enter the link code.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            string deviceId = GetDeviceId();
            if (string.IsNullOrEmpty(deviceId) || deviceId == "UNKNOWN")
            {
                MessageBox.Show("Could not get device ID, Please check your network configuration", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            var deviceInfo = GetDeviceInfo();
            try
            {
                var requestData = new
                {
                    linkCode = linkCode,
                    deviceId = deviceId,
                    deviceInfo = deviceInfo
                };
                string jsonData = JsonSerializer.Serialize(requestData);
                var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await httpClient.PostAsync($"{serverBaseUrl}/api/linkClient", content);

                if (response.IsSuccessStatusCode)
                {
                    string responseContent = await response.Content.ReadAsStringAsync();
                    try
                    {
                        var linkedAccount = JsonSerializer.Deserialize<JsonElement>(responseContent);
                        string gamertag = linkedAccount.GetProperty("gamertag").GetString();
                        string uuid = linkedAccount.GetProperty("uuid").GetString();

                        if (!string.IsNullOrEmpty(gamertag) && !string.IsNullOrEmpty(uuid))
                        {
                            SaveLinkingInformation(deviceId, gamertag, uuid);
                            linkedAccountLabel.Text = $"Linked to: {gamertag}";
                            MessageBox.Show("Client linked successfully!", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            linkAccountButton.Enabled = false;
                            unlinkAccountButton.Enabled = true;
                        }
                        else
                        {
                            MessageBox.Show("Client linked sucessfully but could not obtain the gamertag or uuid from backend", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Client linked sucessfully but could not obtain the gamertag or uuid from backend: {ex.Message}", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }

                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    try
                    {
                        var error = JsonSerializer.Deserialize<JsonElement>(errorContent).GetProperty("error").GetString();
                        MessageBox.Show($"Failed to link client: {error}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Failed to link client with error: {ex.Message}, Full response: {errorContent}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error linking client: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private async void UnlinkAccountButton_Click(object sender, EventArgs e)
        {
            string uuid = LoadLinkingInformation(uuidValueName);
            if (string.IsNullOrEmpty(uuid))
            {
                MessageBox.Show("Could not get UUID from local registry, please try linking again", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            unlinkAccountButton.Enabled = false;
            unlinkAccountButton.Text = "Unlinking...";
            try
            {
                var requestData = new { uuid = uuid };
                string jsonData = JsonSerializer.Serialize(requestData);
                var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await httpClient.PostAsync($"{serverBaseUrl}/api/unlinkClient", content);

                if (response.IsSuccessStatusCode)
                {
                    MessageBox.Show("Client unlinked successfully!", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    linkAccountButton.Enabled = true;
                    unlinkAccountButton.Enabled = false;
                    linkedAccountLabel.Text = "Not Linked";
                    ClearLinkingInformation(); // Remove registry values for this client
                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    try
                    {
                        var error = JsonSerializer.Deserialize<JsonElement>(errorContent).GetProperty("error").GetString();
                        MessageBox.Show($"Failed to unlink client: {error}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Failed to unlink client with error: {ex.Message}, Full response: {errorContent}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error unlinking client: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                unlinkAccountButton.Enabled = true;
                unlinkAccountButton.Text = "Unlink Account";
            }
        }

        private async Task CheckLinkedAccountOnStartup()
        {
            string storedDeviceId = LoadLinkingInformation(deviceIdValueName);
            string uuid = LoadLinkingInformation(uuidValueName);

            if (string.IsNullOrEmpty(storedDeviceId))
            {
                linkedAccountLabel.Text = "Not Linked";
                linkAccountButton.Enabled = true;
                unlinkAccountButton.Enabled = false;
                return;
            }

            try
            {
                var requestData = new { deviceId = storedDeviceId };
                string jsonData = JsonSerializer.Serialize(requestData);
                var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await httpClient.PostAsync($"{serverBaseUrl}/api/getLinkedAccount", content);

                if (response.IsSuccessStatusCode)
                {
                    string responseContent = await response.Content.ReadAsStringAsync();
                    try
                    {
                        var linkedAccount = JsonSerializer.Deserialize<JsonElement>(responseContent);
                        string gamertag = linkedAccount.GetProperty("gamertag").GetString();
                        if (!string.IsNullOrEmpty(gamertag))
                        {
                            linkedAccountLabel.Text = $"Linked to: {gamertag}";
                            linkAccountButton.Enabled = false;
                            unlinkAccountButton.Enabled = true;
                            SaveLinkingInformation(storedDeviceId, gamertag, uuid);
                        }
                        else
                        {
                            ClearLinkingInformation();
                            linkedAccountLabel.Text = "Not Linked";
                            linkAccountButton.Enabled = true;
                            unlinkAccountButton.Enabled = false;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error deserializing or accessing JSON: {ex.Message} Response: {responseContent}");
                        ClearLinkingInformation();
                        linkedAccountLabel.Text = "Not Linked";
                        linkAccountButton.Enabled = true;
                        unlinkAccountButton.Enabled = false;
                    }

                }
                else
                {
                    ClearLinkingInformation();
                    linkedAccountLabel.Text = "Not Linked";
                    linkAccountButton.Enabled = true;
                    unlinkAccountButton.Enabled = false;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error checking linked account: {ex.Message}");
                linkedAccountLabel.Text = "Error checking link";
                linkAccountButton.Enabled = true;
                unlinkAccountButton.Enabled = false;
            }
        }

        private void SaveLinkingInformation(string deviceId, string gamertag, string uuid)
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.CreateSubKey(registryKeyName))
                {
                    if (key != null)
                    {
                        key.SetValue(deviceIdValueName, deviceId);
                        key.SetValue(linkedGamertagValueName, gamertag);
                        if (!string.IsNullOrEmpty(uuid))
                        {
                            key.SetValue(uuidValueName, uuid);
                        }

                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to save linking information in the registry: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private string LoadLinkingInformation(string keyToLoad)
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(registryKeyName))
                {
                    if (key != null)
                    {
                        return key.GetValue(keyToLoad) as string;
                    }
                }
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load {keyToLoad} from registry: {ex.Message}");
                return null; // Return null to indicate no device ID
            }

        }
        private void ClearLinkingInformation()
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(registryKeyName, true))
                {
                    if (key != null)
                    {
                        key.DeleteValue(deviceIdValueName, false);
                        key.DeleteValue(linkedGamertagValueName, false);
                        key.DeleteValue(uuidValueName, false);
                    }
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to clear registry keys: {ex.Message}");
            }

        }
        private string GetDeviceId()
        {
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
            var macAddr = (from nic in nics
                           where nic.OperationalStatus == OperationalStatus.Up && nic.NetworkInterfaceType != NetworkInterfaceType.Loopback
                           select nic.GetPhysicalAddress().ToString()).FirstOrDefault();
            return macAddr ?? "UNKNOWN";
        }

        private object GetDeviceInfo()
        {
            return new
            {
                OSVersion = Environment.OSVersion.VersionString,
                MachineName = Environment.MachineName,
                UserName = Environment.UserName
            };
        }

        private void Main_FormClosing(object sender, FormClosingEventArgs e)
        {
            httpClient.Dispose();
        }
        private void LoadStaticBaselines()
        {
            try
            {
                string baselineModulesText = Properties.Resources.baseline_modules;
                if (!string.IsNullOrEmpty(baselineModulesText))
                {
                    baselineModules = new HashSet<string>(baselineModulesText.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries));
                    UpdateStatusLabel("Baseline modules loaded from resources.", successColor);
                }
                else
                {
                    UpdateStatusLabel("Error loading baseline modules from resources.", warningColor);
                }

            }
            catch (Exception ex)
            {
                UpdateStatusLabel($"Error loading static baselines: {ex.Message}", Color.DarkRed);
            }
        }
    }

    public class UpdateResponse
    {
        public bool isUpToDate { get; set; }
        public string downloadUrl { get; set; }
    }
}